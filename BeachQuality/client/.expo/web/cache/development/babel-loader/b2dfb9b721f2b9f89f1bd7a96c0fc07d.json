{"ast":null,"code":"import _ from \"lodash\";\nimport customMerge from \"./customMerge\";\n\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\nfunction splitStyle(style) {\n  return _.reduce(style, function (result, value, key) {\n    var styleSection = result.componentStyle;\n\n    if (isStyleVariant(key)) {\n      styleSection = result.styleVariants;\n    } else if (isChildStyle(key)) {\n      styleSection = result.childrenStyle;\n    }\n\n    styleSection[key] = value;\n    return result;\n  }, {\n    componentStyle: {},\n    styleVariants: {},\n    childrenStyle: {}\n  });\n}\n\nexport function resolveComponentStyle(componentName) {\n  var styleNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var themeStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var parentStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var themeCache = arguments.length > 4 ? arguments[4] : undefined;\n  var mergedStyle = customMerge(themeStyle, parentStyle[componentName]);\n  styleNames.forEach(function (sn, index) {\n    mergedStyle = customMerge(mergedStyle, themeStyle[\"\" + sn]);\n  });\n  styleNames.forEach(function (sn, index) {\n    mergedStyle = customMerge(mergedStyle, parentStyle[\"\" + componentName + sn]);\n  });\n  var resolvedStyle = customMerge(mergedStyle, parentStyle[componentName]);\n  styleNames.forEach(function (sn, index) {\n    resolvedStyle = customMerge(resolvedStyle, mergedStyle[\"\" + sn]);\n  });\n  styleNames.forEach(function (sn, index) {\n    resolvedStyle = customMerge(resolvedStyle, parentStyle[\"\" + componentName + sn]);\n  });\n  return resolvedStyle;\n}","map":{"version":3,"sources":["C:/Users/user/semester-project-team2/BeachQuality/client/node_modules/native-base-shoutem-theme/src/resolveComponentStyle.js"],"names":["_","customMerge","isStyleVariant","propertyName","test","isChildStyle","splitStyle","style","reduce","result","value","key","styleSection","componentStyle","styleVariants","childrenStyle","resolveComponentStyle","componentName","styleNames","themeStyle","parentStyle","themeCache","mergedStyle","forEach","sn","index","resolvedStyle"],"mappings":"AAAA,OAAOA,CAAP,MAAc,QAAd;AACA,OAAOC,WAAP;;AAWA,SAASC,cAAT,CAAwBC,YAAxB,EAAsC;AACpC,SAAO,MAAMC,IAAN,CAAWD,YAAX,CAAP;AACD;;AAcD,SAASE,YAAT,CAAsBF,YAAtB,EAAoC;AAClC,SAAO,oBAAoBC,IAApB,CAAyBD,YAAzB,CAAP;AACD;;AAWD,SAASG,UAAT,CAAoBC,KAApB,EAA2B;AACzB,SAAOP,CAAC,CAACQ,MAAF,CACLD,KADK,EAEL,UAACE,MAAD,EAASC,KAAT,EAAgBC,GAAhB,EAAwB;AACtB,QAAIC,YAAY,GAAGH,MAAM,CAACI,cAA1B;;AACA,QAAIX,cAAc,CAACS,GAAD,CAAlB,EAAyB;AACvBC,MAAAA,YAAY,GAAGH,MAAM,CAACK,aAAtB;AACD,KAFD,MAEO,IAAIT,YAAY,CAACM,GAAD,CAAhB,EAAuB;AAC5BC,MAAAA,YAAY,GAAGH,MAAM,CAACM,aAAtB;AACD;;AACDH,IAAAA,YAAY,CAACD,GAAD,CAAZ,GAAoBD,KAApB;AACA,WAAOD,MAAP;AACD,GAXI,EAYL;AACEI,IAAAA,cAAc,EAAE,EADlB;AAEEC,IAAAA,aAAa,EAAE,EAFjB;AAGEC,IAAAA,aAAa,EAAE;AAHjB,GAZK,CAAP;AAkBD;;AAyBD,OAAO,SAASC,qBAAT,CACLC,aADK,EAML;AAAA,MAJAC,UAIA,uEAJa,EAIb;AAAA,MAHAC,UAGA,uEAHa,EAGb;AAAA,MAFAC,WAEA,uEAFc,EAEd;AAAA,MADAC,UACA;AAUA,MAAIC,WAAW,GAAGrB,WAAW,CAACkB,UAAD,EAAaC,WAAW,CAACH,aAAD,CAAxB,CAA7B;AACAC,EAAAA,UAAU,CAACK,OAAX,CAAmB,UAACC,EAAD,EAAKC,KAAL,EAAe;AAChCH,IAAAA,WAAW,GAAGrB,WAAW,CAACqB,WAAD,EAAcH,UAAU,MAAIK,EAAJ,CAAxB,CAAzB;AACD,GAFD;AAIAN,EAAAA,UAAU,CAACK,OAAX,CAAmB,UAACC,EAAD,EAAKC,KAAL,EAAe;AAChCH,IAAAA,WAAW,GAAGrB,WAAW,CACvBqB,WADuB,EAEvBF,WAAW,MAAIH,aAAJ,GAAoBO,EAApB,CAFY,CAAzB;AAID,GALD;AAmBA,MAAIE,aAAa,GAAGzB,WAAW,CAACqB,WAAD,EAAcF,WAAW,CAACH,aAAD,CAAzB,CAA/B;AAEAC,EAAAA,UAAU,CAACK,OAAX,CAAmB,UAACC,EAAD,EAAKC,KAAL,EAAe;AAChCC,IAAAA,aAAa,GAAGzB,WAAW,CAACyB,aAAD,EAAgBJ,WAAW,MAAIE,EAAJ,CAA3B,CAA3B;AACD,GAFD;AAIAN,EAAAA,UAAU,CAACK,OAAX,CAAmB,UAACC,EAAD,EAAKC,KAAL,EAAe;AAChCC,IAAAA,aAAa,GAAGzB,WAAW,CACzByB,aADyB,EAEzBN,WAAW,MAAIH,aAAJ,GAAoBO,EAApB,CAFc,CAA3B;AAID,GALD;AAOA,SAAOE,aAAP;AACD","sourcesContent":["import _ from \"lodash\";\r\nimport customMerge from \"./customMerge\";\r\n\r\n/**\r\n * Matches any style properties that represent component style variants.\r\n * Those styles can be applied to the component by using the styleName\r\n * prop. All style variant property names must start with a single '.'\r\n * character, e.g., '.variant'.\r\n *\r\n * @param propertyName The style property name.\r\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\r\n */\r\nfunction isStyleVariant(propertyName) {\r\n  return /^\\./.test(propertyName);\r\n}\r\n\r\n/**\r\n * Matches any style properties that represent style rules that target the\r\n * component children. Those styles can have two formats, they can either\r\n * target the components by component name ('shoutem.ui.Text'), or by component\r\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\r\n * component name, those styles can also target any component by using the\r\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\r\n * that they have to contain a '.' character in their name or be a '*'.\r\n *\r\n * @param propertyName The style property name.\r\n * @returns {boolean} True if the style property represents a child style, false otherwise.\r\n */\r\nfunction isChildStyle(propertyName) {\r\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\r\n}\r\n\r\n/**\r\n * Splits the style into its parts:\r\n * component style - concrete style that needs to be applied to a component\r\n * style variants - variants that can be applied to a component by using styleName prop\r\n * children style - style rules that need to be propagated to component children\r\n *\r\n * @param style The style to split.\r\n * @returns {*} An object with the componentStyle, styleVariants, and childrenStyle keys.\r\n */\r\nfunction splitStyle(style) {\r\n  return _.reduce(\r\n    style,\r\n    (result, value, key) => {\r\n      let styleSection = result.componentStyle;\r\n      if (isStyleVariant(key)) {\r\n        styleSection = result.styleVariants;\r\n      } else if (isChildStyle(key)) {\r\n        styleSection = result.childrenStyle;\r\n      }\r\n      styleSection[key] = value;\r\n      return result;\r\n    },\r\n    {\r\n      componentStyle: {},\r\n      styleVariants: {},\r\n      childrenStyle: {}\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Resolves the final component style by merging all of the styles that can be\r\n * applied to a component in the proper order.\r\n *\r\n * This function extracts the applicable parts of the theme, parent and element\r\n * styles, and merges the styles that target the component, and component variants\r\n * with those styles to get the final style.\r\n *\r\n * The styles are merged in the following order, where the styles with the\r\n * higher index override the styles with the lower one:\r\n * 1. Theme component style\r\n * 2. Parent component style\r\n * 3. Theme style variants specified through styleName\r\n * 4. Parent style variants specified through styleName\r\n * 5. Element style passed through the style prop\r\n *\r\n * @param componentName The component name ('shoutem.ui.Text')\r\n * @param styleName Style names ('large rounded')\r\n * @param themeStyle The theme style that should include the theme and base component style\r\n * @param parentStyle The style rules inherited from the parent component\r\n * @param elementStyle The style passed through the style prop of the component\r\n * @returns {{componentStyle, childrenStyle}} The resolved component and children styles.\r\n */\r\nexport function resolveComponentStyle(\r\n  componentName,\r\n  styleNames = [],\r\n  themeStyle = {},\r\n  parentStyle = {},\r\n  themeCache\r\n) {\r\n  // const mergedStyle = _.merge({},\r\n  //   themeStyle,\r\n  //   parentStyle['*'],\r\n  //   parentStyle[componentName],\r\n  //   ..._.map(styleNames, (sn) => themeStyle[`.${sn}`]),\r\n  //   ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\r\n  //   ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`])\r\n  // );\r\n\r\n  let mergedStyle = customMerge(themeStyle, parentStyle[componentName]);\r\n  styleNames.forEach((sn, index) => {\r\n    mergedStyle = customMerge(mergedStyle, themeStyle[`${sn}`]);\r\n  });\r\n\r\n  styleNames.forEach((sn, index) => {\r\n    mergedStyle = customMerge(\r\n      mergedStyle,\r\n      parentStyle[`${componentName}${sn}`]\r\n    );\r\n  });\r\n\r\n  // Phase 2: merge the component styles, this step is performed by using the\r\n  // style from phase 1, so that we are sure that the final style variants are\r\n  // applied to component style.\r\n  // const resolvedStyle = _.merge({},\r\n  //   mergedStyle,\r\n  //   parentStyle['*'],\r\n  //   parentStyle[componentName],\r\n  //   ..._.map(styleNames, (sn) => mergedStyle[`.${sn}`]),\r\n  //   ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\r\n  //   ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`])\r\n  // );\r\n\r\n  let resolvedStyle = customMerge(mergedStyle, parentStyle[componentName]);\r\n\r\n  styleNames.forEach((sn, index) => {\r\n    resolvedStyle = customMerge(resolvedStyle, mergedStyle[`${sn}`]);\r\n  });\r\n\r\n  styleNames.forEach((sn, index) => {\r\n    resolvedStyle = customMerge(\r\n      resolvedStyle,\r\n      parentStyle[`${componentName}${sn}`]\r\n    );\r\n  });\r\n\r\n  return resolvedStyle;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}