function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import queryString from 'query-string';

/**
 * Utility to parse a path string to initial state object accepted by the container.
 * This is useful for deep linking when we need to handle the incoming URL.
 *
 * Example:
 * ```js
 * getStateFromPath(
 *   '/chat/jane/42',
 *   {
 *     Chat: {
 *       path: 'chat/:author/:id',
 *       parse: { id: Number }
 *     }
 *   }
 * )
 * ```
 * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
 * @param options Extra options to fine-tune how to parse the path.
 */
export default function getStateFromPath(path, options = {}) {
  let initialRoutes = []; // Create a normalized configs array which will be easier to use

  const configs = [].concat(...Object.keys(options).map(key => createNormalizedConfigs(key, options, [], initialRoutes))); // sort configs so the most exhaustive is always first to be chosen

  configs.sort((config1, config2) => config2.pattern.split('/').length - config1.pattern.split('/').length);
  let remaining = path.replace(/[/]+/, '/') // Replace multiple slash (//) with single ones
  .replace(/^\//, '') // Remove extra leading slash
  .replace(/\?.*/, ''); // Remove query params which we will handle later

  if (remaining === '') {
    // We need to add special handling of empty path so navigation to empty path also works
    // When handling empty path, we should only look at the root level config
    const match = configs.find(config => config.pattern === '' && config.routeNames.every( // make sure that none of the parent configs have a non-empty path defined
    name => {
      var _configs$find;

      return !((_configs$find = configs.find(c => c.screen === name)) === null || _configs$find === void 0 ? void 0 : _configs$find.pattern);
    }));

    if (match) {
      return createNestedStateObject(match.routeNames, initialRoutes, parseQueryParams(path, match.parse));
    }

    return undefined;
  }

  let result;
  let current;

  while (remaining) {
    let routeNames;
    let params; // Go through all configs, and see if the next path segment matches our regex

    for (const config of configs) {
      if (!config.match) {
        continue;
      }

      let didMatch = true;
      const matchParts = config.match.split('/');
      const remainingParts = remaining.split('/'); // we check if remaining path has enough segments to be handled with this pattern

      if (config.pattern.split('/').length > remainingParts.length) {
        continue;
      } // we keep info about the index of segment on which the params start


      let paramsIndex = 0; // the beginning of the remaining path should be the same as the part of config before params

      for (paramsIndex; paramsIndex < matchParts.length; paramsIndex++) {
        if (matchParts[paramsIndex] !== remainingParts[paramsIndex]) {
          didMatch = false;
          break;
        }
      } // If the first part of the path matches, we need to extract params from the path


      if (didMatch) {
        routeNames = [...config.routeNames];
        const paramPatterns = config.pattern.split('/').filter(p => p.startsWith(':'));

        if (paramPatterns.length) {
          params = paramPatterns.reduce((acc, p, i) => {
            const key = p.replace(/^:/, '');
            const value = remainingParts[i + paramsIndex]; // The param segments start from the end of matched part

            acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;
            return acc;
          }, {});
        } // if pattern and remaining path have same amount of segments, there should be nothing left


        if (config.pattern.split('/').length === remainingParts.length) {
          remaining = '';
        } else {
          // For each segment of the pattern, remove one segment from remaining path
          let i = config.pattern.split('/').length;

          while (i--) {
            remaining = remaining.substr(remaining.indexOf('/') + 1);
          }
        }

        break;
      }
    } // If we hadn't matched any segments earlier, use the path as route name


    if (routeNames === undefined) {
      const segments = remaining.split('/');
      routeNames = [decodeURIComponent(segments[0])];
      segments.shift();
      remaining = segments.join('/');
    }

    const state = createNestedStateObject(routeNames, initialRoutes, params);

    if (current) {
      var _current2;

      // The state should be nested inside the deepest route we parsed before
      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {
        var _current;

        current = current.routes[current.index || 0].state;
      }

      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;
    } else {
      result = state;
    }

    current = state;
  }

  if (current == null || result == null) {
    return undefined;
  }

  const route = findFocusedRoute(current);
  const params = parseQueryParams(path, findParseConfigForRoute(route.name, configs));

  if (params) {
    route.params = _objectSpread({}, route.params, {}, params);
  }

  return result;
}

function createNormalizedConfigs(key, routeConfig, routeNames = [], initials) {
  const configs = [];
  routeNames.push(key);
  const value = routeConfig[key];

  if (typeof value === 'string') {
    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
    configs.push(createConfigItem(key, routeNames, value));
  } else if (typeof value === 'object') {
    // if an object is specified as the value (e.g. Foo: { ... }),
    // it can have `path` property and
    // it could have `screens` prop which has nested configs
    if (typeof value.path === 'string') {
      configs.push(createConfigItem(key, routeNames, value.path, value.parse));
    }

    if (value.screens) {
      // property `initialRouteName` without `screens` has no purpose
      if (value.initialRouteName) {
        initials.push({
          initialRouteName: value.initialRouteName,
          connectedRoutes: Object.keys(value.screens)
        });
      }

      Object.keys(value.screens).forEach(nestedConfig => {
        const result = createNormalizedConfigs(nestedConfig, value.screens, routeNames, initials);
        configs.push(...result);
      });
    }
  }

  routeNames.pop();
  return configs;
}

function createConfigItem(screen, routeNames, pattern, parse) {
  // part being matched ends on the first param
  const match = pattern !== '' ? pattern.split('/:')[0] : null;
  return {
    screen,
    match,
    pattern,
    // The routeNames array is mutated, so copy it to keep the current state
    routeNames: [...routeNames],
    parse
  };
}

function findParseConfigForRoute(routeName, flatConfig) {
  for (const config of flatConfig) {
    if (routeName === config.routeNames[config.routeNames.length - 1]) {
      return config.parse;
    }
  }

  return undefined;
} // tries to find an initial route connected with the one passed


function findInitialRoute(routeName, initialRoutes) {
  for (const config of initialRoutes) {
    if (config.connectedRoutes.includes(routeName)) {
      return config.initialRouteName === routeName ? undefined : config.initialRouteName;
    }
  }

  return undefined;
} // returns state object with values depending on whether
// it is the end of state and if there is initialRoute for this level


function createStateObject(initialRoute, routeName, isEmpty, params) {
  if (isEmpty) {
    if (initialRoute) {
      return {
        index: 1,
        routes: [{
          name: initialRoute
        }, _objectSpread({
          name: routeName
        }, params && {
          params
        })]
      };
    } else {
      return {
        routes: [_objectSpread({
          name: routeName
        }, params && {
          params
        })]
      };
    }
  } else {
    if (initialRoute) {
      return {
        index: 1,
        routes: [{
          name: initialRoute
        }, {
          name: routeName,
          state: {
            routes: []
          }
        }]
      };
    } else {
      return {
        routes: [{
          name: routeName,
          state: {
            routes: []
          }
        }]
      };
    }
  }
}

function createNestedStateObject(routeNames, initialRoutes, params) {
  let state;
  let routeName = routeNames.shift();
  let initialRoute = findInitialRoute(routeName, initialRoutes);
  state = createStateObject(initialRoute, routeName, routeNames.length === 0, params);

  if (routeNames.length > 0) {
    let nestedState = state;

    while (routeName = routeNames.shift()) {
      initialRoute = findInitialRoute(routeName, initialRoutes);
      nestedState.routes[nestedState.index || 0].state = createStateObject(initialRoute, routeName, routeNames.length === 0, params);

      if (routeNames.length > 0) {
        nestedState = nestedState.routes[nestedState.index || 0].state;
      }
    }
  }

  return state;
}

function findFocusedRoute(state) {
  var _current4;

  let current = state;

  while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {
    var _current3;

    // The query params apply to the deepest route
    current = current.routes[current.index || 0].state;
  }

  const route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];
  return route;
}

function parseQueryParams(path, parseConfig) {
  const query = path.split('?')[1];
  const params = queryString.parse(query);

  if (parseConfig) {
    Object.keys(params).forEach(name => {
      if (parseConfig[name] && typeof params[name] === 'string') {
        params[name] = parseConfig[name](params[name]);
      }
    });
  }

  return Object.keys(params).length ? params : undefined;
}
//# sourceMappingURL=getStateFromPath.js.map